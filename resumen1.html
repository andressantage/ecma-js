<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CampusLand</title>
    <link rel="stylesheet" href="prism.css">
    <link rel="shortcut icon" href="img/logo.png" type="image/x-icon">
	<script src="prism.js"></script>
    <style>
body{
    background-color: black;
}
.cuadro{
    display: flex;
    justify-content: center;
}
    </style>
</head>
<body>
<h1>ECMA</h1>
    <div class="cuadro">
<pre><code class="language-javascript">
ECMAScript:
es un estandar para lenguaje de programacion. ya que fue regulado inicialmente}
por la ECMA. Versiones de javascript

TC39:
grupo de desarrolladores que estan a cargo de revisar cada propuesta o 
funcionalidad que cumpla con el estandar

ESNext es un nombre que siempre indica la próxima versión de javascript y esto consta de los siguientes pasos:

    Stage0: Strawperson (borrador, cualquier persona puede tener una idea para implementar en el estandar)

    Stage1: Proposal (propuesta formal)

    Stage2: Draft (borrador, como va a funcionar la implementacion el impacto entre otros)

    Stage3: Candidate (se elige el candidato, vamos a tener una propuesta que va ayudar a mejorar el lenguaje.)

    Stage4: Finished (va a ser desplegada en la version normalmente en JUNIO)

ES6 o ES2015:
nueva declaracion de variables:
let, const
nuevas funciones:
funciones flechas

Las nuevas palabras reservadas let y const resuelven varios problemas con var como el scope, hoisting, variables globales, re-declaración y re-asignación de variables.

Variables re-declaradas y re-asignadas
La re-declaración es volver a declarar una variable, y la re-asignación es volver a asignar un valor
*Una variable declarada con var puede ser re-declarada y re-asignada.
*Una variable declarada con let puede ser re-asignada, pero no re-declarada.
*Una variable declarada con const no puede ser re-declarada, ni re-asignada. Su declaración y asignación debe ser en una línea, caso contrario habrá un error.
En conclusión, si intentas re-declarar una variable declarada con let y const habrá un error de “variable ya declarada”; por otro lado, si intentas re-asignar una variable declarada con const existirá un “error de tipo”.

"dejar de utilizar var"

// Declaración de variables
var nameVar
let nameLet

// Asignación de variables
nameVar= "soy var"
nameLet = "soy let"

Aunque realmente lo que pasa si no asignas un valor en la declaración, JavaScript le asigna un valor undefined.

//siempre asignar con const un valor a la varuable
const pi  // SyntaxError: Missing initializer in const declaration.

Ejemplo de re-declaración de variables:
var nameVar = "soy var"
let nameLet = "soy let"
const nameConst = "soy const"
// Re-declaración de variables
var nameVar = "var soy"
console.log(nameVar) // 'var soy'
let nameLet = "let soy" // SyntaxError: Identifier 'nameLet' has already been declared.
const nameConst = "const soy" //SyntaxError: Identifier 'nameConst' has already been declared.

Ejemplo de re-asignación de variables:
var nameVar = "soy var"
let nameLet = "soy let"
const nameConst = "soy const"
// Re-asignación de variables
nameVar = "otro var"
console.log(nameVar) // 'otro var'
nameLet = "otro let"
console.log(nameVar) // otro let'
nameConst = "otro const" //TypeError: Assignment to constant variable.

Scope
En el tema del scope, let y const tienen un scope de bloque y var no.
ejemplo:
{
var nameVar = "soy var"
let nameLet = "soy let"
}
console.log(nameVar) // 'soy var'
console.log(nameLet) // ReferenceError: nameLet is not defined

Objeto global
En variables globales, let y const no guardan sus variables en el objeto global (window, global o globalThis), mientras que var sí los guarda.
var nameVar = "soy var"
let nameLet = "soy let"
const nameConst = "soy const"

globalThis.nameVar   // 'soy var'
globalThis.nameLet   // undefined
globalThis.nameConst  // undefined

Funciones flecha

Las funciones flecha (arrow functions) consiste en una función anónima con la siguiente estructura:
//Función tradicional
function nombre (parámetros) {
    return valorRetornado
}
//Función flecha
const nombre = (parámetros) => {
    return valorRetornado
}

Se denominan función flecha por el elemento => en su sintaxis.

Omitir paréntesis en las funciones flecha:
Si existe un solo parámetro, puedes omitir los paréntesis.
const porDos = num => {
    return num * 2
}

Retorno implícito
Las funciones flecha tienen un retorno implícito, es decir, se puede omitir la palabra reservada return, para que el código sea escrito en una sola línea.
//Función tradicional
function suma (num1, num2) {
    return num1 + num2
}
//Función flecha
const suma = (num1, num2) => num1 + num2

Si el retorno requiere de más líneas y aún deseas utilizarlo de manera implícita, deberás envolver el cuerpo de la función entre paréntesis.
const suma = (num1, num2) => (
    num1 + num2
)
const suma = num1=>num1*3

//funcion anonima:
const suma = (num1, num2) => num1 + num2
suma(2,3)//5

ES6: strings
Las plantillas literales (template literals) consisten en crear cadenas de caracteres que puedan contener variables sin utilizar la concatenación. Esto mejora la legibilidad y la mantenibilidad del código.

Concatenación de caracteres
Antes de ES6, si querías crear una cadena larga o un mensaje elaborado, debías utilizar la concatenación. La concatenación de caracteres consiste en unir uno o varios caracteres, como si fuera una suma.
var nombre = "Andres"
var edad = 23
var mensaje = "Mi nombre es " + nombre + " y tengo " + edad + " años."
console.log(mensaje) // 'Mi nombre es Andres y tengo 23 años.'

Esto trae varios problemas en la legibilidad y mantenibilidad del código. Se convierte cada vez más complejo en mensajes más extensos o el estar pendiente de agregar espacios antes o después de cada variable concatenada.

Cómo utilizar las plantillas literales
Las plantillas literales añadidas en ES6, se emplea el caracter acento grave ( ` ), que no es una comilla simple ( ’ ), para envolver el mensaje. Para incluir las variables se utiliza la sintaxis ${variable}.
var nombre = "Andres"
var edad = 23
var mensaje = `Mi nombre es ${nombre} y tengo ${edad} años.`
console.log(mensaje) // 'Mi nombre es Andres y tengo 23 años.'

De esta manera el código es más legible y que pueda mantenerse.

Plantilla multilínea
La plantilla multilínea consiste en crear mensajes que contengan varias líneas separadas entre sí, utilizando las plantillas literales. Antes de ES6, la forma de crear una plantilla multilínea era agregar \n al string.
var mensaje = "Línea 1 \n" + "línea 2"
console.log(mensaje)
// 'Línea 1
// línea 2'

Con ES6 solamente necesitas utilizar las plantillas literales.
const mensaje = `Línea 1
línea 2`
console.log(mensaje)
// 'Línea 1
// línea 2'

ES6: parámetros por defecto
Los parámetros por defecto (default params) consisten en establecer un valor por defecto a los parámetros de una función, para asegurar que el código se ejecute correctamente en el caso de que no se establezcan los argumentos correspondientes en la invocación de la función.

Cómo era utilizar valores por defecto antes de ES6
Tal como puedes ver en el siguiente código, la función sumar recibe dos parámetros y retorna el valor total. Sin embargo, si alguien no decide poner alguno o todos los parámetros necesarios, pues que el programa no funcionará correctamente.
function sumar(number1, number2){
  return number1 + number2
}
sumar(3,4) // 7
sumar(3)   // NaN  
sumar()    // NaN

Antes de ES6, se debía establecer una variable y utilizar el operador OR ( ||) con el valor por defecto necesario. El caracter guion bajo ( _) lo utilizo para diferenciar el parámetro de la función de la variable declarada.
function sumar(number1, number2){
  var _number1 = number1 || 0
  var _number2 = number2 || 0
 
  return _number1 + _number2
}
sumar(3,4) // 7
sumar(3)   // 3
sumar()    // 0

Puedes utilizar cualquier valor, siempre que sea necesario.

Posición de los parámetros por defecto
Si obligatoriamente necesitas el valor como argumento, ten presente que los parámetros por defecto siempre deben estar en las posiciones finales.
// ❌ Mal
function sumar(number1 = 0, number2) { //proceso% }
sumar(3)   // number1 = 3 y number2 = undefined
// ✅ Bien
function sumar(number1, number2 = 0) { //proceso% }
sumar(3)   // number1 = 3 y number2 = 0

otra forma:
both argument are passed
sum(5,15);
function sum(x=3,y=5){
    return x+y;
}
one argument is passed
sum(7);//aqui tomar solo el valor de x=7
function sum(x=3,y=5){
    return x+y;
}
no argument is passed
sum();//x=3, y=5
function sum(x=3,y=5){
    return x+y;
}

ES6: asignación de desestructuración
La desestructuración (destructuring) consiste en extraer los valores de arrays o propiedades de objetos en distintas variables.

Desestructuración de objetos
La desestructuración de objetos implica extraer las propiedades de un objeto en variables. Mediante el mismo nombre de la propiedad del objeto con la siguiente sintaxis:
const objeto = {
    prop1: "valor1",
    prop2: "valor2",
}
// Desestructuración
const { prop1, prop2 } = objeto// AQUI EN ESTE CASO PROP1 DEBE LLAMARSE IGUAL A LA LLAVE DEL OBJETO SI O SI.
console.log(prop1) //valor1  //LO DE LA LLAVE DEL OBJETO SE GUARDA EN prop1
console.log(prop1) //valor2

Antes de ES6, necesitabas acceder al objeto con la notación punto o corchetes por cada propiedad que se necesita y asignar ese valor a una variable diferente.
var usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
var nombre = usuario.nombre
var edad = usuario.edad
var plataforma = usuario["plataforma"]
console.log(nombre)  // 'Andres'
console.log(edad)  // 23
console.log(plataforma)  // 'Platzi'

Con la desestructuración puedes realizar lo mismo, pero en una sola línea, provocando que el código seas más legible y mantenible.
const usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
const { nombre, edad, plataforma } = usuario
console.log(nombre)  // 'Andres'
console.log(edad)  // 23
console.log(plataforma)  // 'Platzi'

Cambiar el nombre de las variables con desestructuración
Si no te agrada el nombre de la propiedad del objeto, puedes cambiarlo utilizando la siguiente sintaxis:
const objeto = { prop1: "valor1", prop2: "valor2" }
// Desestructuración
const { prop1: newProp1, prop2: newProp2 } = objeto
console.log(prop1)  // GENERA ERROR: prop1 is not defined
console.log(newProp1)  // valor1

Por ejemplo:
const usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
const { nombre: name, edad: age, plataforma: platform } = usuario
console.log(name)  // 'Andres'
console.log(age)  // 23
console.log(platform)  // 'Platzi'
console.log(nombre)   // Uncaught ReferenceError: nombre is not defined

Desestructuración en parámetros de una función
Si envías un objeto como argumento en la invocación a la declaración de una función, puedes utilizar la desestructuración en los parámetros para obtener los valores directamente. Ten en cuenta que el nombre debe ser igual a la propiedad del objeto.
const usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
function mostrarDatos( { nombre, edad, plataforma } ){
    console.log(nombre, edad, plataforma)
}
mostrarDatos(usuario) // 'Andres', 23, 'Platzi'

Desestructuración de arrays
La desestructuración de arrays consiste en extraer los valores de un array en variables, utilizando la misma posición del array con una sintaxis similar a la desestructuración de objetos.
const array = [ 1, 2, 3, 4, 5 ]
// Desestructuración
const [uno, dos, tres ] = array
console.log(uno) // 1
console.log(dos) // 2
console.log(tres) // 3

Desestructuración para valores retornados de una función
Cuando una función retorna un array, puedes guardarlo en una variable. Por ende, puedes utilizar la desestructuración para utilizar esos valores por separado de manera legible.

En el siguiente ejemplo, la función useState retorna un array con dos elementos: un valor y otra función actualizadora.
=> (función useState) (value es el valor, updateValue() es la funcion actualizadora) retorna un array con dos elementos: un valor y otra función actualizadora.
function updateValue(value){
return value*2
}
function useState(value){
    return [value, updateValue(value)]
}
//Sin desestructuración
const estado = useState(3)
const valor = estado[0]
const actualizador = estado[1]
//Con desestructuración
const [valor, actualizador] = useState(3)

Lo que puedes hacer con desestructuración, pero no es recomendable
Si necesitas un elemento en cierta posición, puedes utilizar la separación por comas para identificar la variable que necesitas.
const array = [ 1, 2, 3, 4, 5 ]
const [ ,,,,  cinco ] = array
console.log(cinco) // 5

Como los arrays son un tipo de objeto, puedes utilizar la desestructuración de objetos mediante el índice y utilizando un nombre para la variable.
const array = [ 1, 2, 3, 4, 5 ]
const {4: cinco} = array //{indice_lista(4): variable_en_el_array}
console.log(cinco) // 5

ES6: spread operator
El operador de propagación (spread operator), como su nombre lo dice, consiste en propagar los elementos de un iterable, ya sea un array o string utilizando tres puntos (...) dentro de un array.
// Para strings
const array = [ ..."Hola"]    // [ 'H', 'o', 'l', 'a' ]
// En arrays
const otherArray = [ ...array]   //[ 'H', 'o', 'l', 'a' ]
También se utiliza para objetos, pero esta característica fue añadida en versiones posteriores de ECMAScript y es denominada propiedades de propagación.

Cómo copiar arrays utilizando el operador de propagación
Para realizar una copia de un array, deberás tener cuidado de la referencia en memoria. Los arrays se guardan en una referencia en la memoria del computador, al crear una copia, este tendrá la misma referencia que el original. Debido a esto, si cambias algo en la copia, también lo harás en el original.
const originalArray = [1,2,3,4,5]
const copyArray = originalArray
copyArray[0] = 0
originalArray // [0,2,3,4,5]
originalArray === copyArray  // true

Para evitar esto, utiliza el operador de propagación para crear una copia del array que utilice una referencia en memoria diferente al original.
const originalArray = [1,2,3,4,5]
const copyArray = [...originalArray]
copyArray[0] = 0
originalArray // [1,2,3,4,5]
copyArray // [0,2,3,4,5]
originalArray === copyArray  // false

Cómo unir arrays y añadir elementos con el operador de propagación
Para unir dos arrays con el operador de propagación, simplemente debes separarlos por comas en un array.
const array1 = [1,2,3]
const number = 4
const array2 = [5,6,7]
const otherArray = [ ...array1, number, ...array2 ]
otherArray // [1,2,3,4,5,6,7]

Cuidado con la copia en diferentes niveles de profundidad
El operador de propagación sirve para producir una copia en un solo nivel de profundidad, esto quiere decir que si existen objetos o arrays dentro del array a copiar. Entonces los sub-elementos en cada nivel, tendrán la misma referencia de memoria en la copia y en el original.
const originalArray = [1, [2,3] ,4,5]
const copyArray = [...originalArray] 
originalArray[1] === copyArray[1] // true, esto es por tener array dentro de un array debido al nivel de profundidad

solucion al problema anterior:
La manera de solucionar es más compleja, tendrías que emplear el operador de propagación para cada elemento en cada nivel de profundidad.
Sin embargo, recientemente salió una forma de producir una copia profunda con StructuredClone, aunque es una característica muy reciente, así que revisa que navegadores tienen soporte.
const originalArray = [1, [2,3] ,4,5]
const copyArray = structuredClone(originalArray)
originalArray === copyArray  // false
originalArray[1] === copyArray[1] // false

Este comportamiento también sucede para objetos dentro de otros objetos, u objetos dentro de arrays.

Parámetro rest
El parámetro rest consiste en agrupar el residuo de elementos mediante la sintaxis de tres puntos (...) seguido de una variable que contendrá los elementos en un array.
Esta característica sirve para crear funciones que acepten cualquier número de argumentos para agruparlos en un array.

function hola (primero, segundo, ...resto) {
  console.log(primero, segundo)  // 1 2
  console.log(resto) // [3,4,5,6]
}
hola(1,2,3,4,5)

También sirve para obtener los elementos restantes de un array u objeto usando desestructuración.
const objeto = {
  nombre: "Andres",
  age: 23,
  plataforma: "Platzi"
}
const array = [0,1,2,3,4,5]
const {plataforma, ...usuario} = objeto
const [cero, ...positivos] = array
usuario // { nombre: 'Andres', age: 23 }
positivos // [ 1, 2, 3, 4, 5 ]

Posición del parámetro rest
El parámetro rest siempre deberá estar en la última posición de los parámetros de la función, caso contrario existirá un error de sintaxis.
// ❌ Mal
function hola (primero, ...rest, ultimo) { ... }
// SyntaxError: Rest element must be last element. 

Diferencias entre el parámetro rest y el operador de propagación
Aunque el parámetro rest y el operador de propagación utilicen la misma sintaxis, son diferentes.
El parámetro rest agrupa el residuo de elementos y siempre debe estar en la última posición, mientras que el operador de propagación expande los elementos de un iterable en un array y no importa en que lugar esté situado.
"operador de propagación expande los elementos de un iterable en un array" expandirlos seria: pasar de [1,2,3,4,5] a 1,2,3,4,5
"rest agrupa el residuo de elementos y siempre debe estar en la última posición"
const array = [1,2,3,4,5]
function hola (primero, segundo, ...resto) { // <- Parámetro Rest
  console.log(primero, segundo)  // 1 2
  console.log(resto) // [3,4,5, "final"]
}
hola(...array, "final") //<- Operador de propagación //Lo mismo que hacer -> hola(1,2,3,4,5, "final")

ejercicio:
function solution(
  json1 = {
    name: "Mr. Michi",
    food: "Pescado"
  },
  json2 = {
    age: 12,
    color: "Blanco"
  }) {
 return { ...json1, ...json2}
}
//entrada:
solution({
    name: "Bigotes",
    food: "Pollito"
})
//salida:
{
    name: "Bigotes",
    food: "Pollito",
    age: 12,
    color: "Blanco"
}

ES6: object literals
Los objetos literales consiste en crear objetos a partir de variables sin repetir el nombre. Antes de ES6, para crear un objeto a partir de variables consistía en la siguiente manera:
const nombre = "Andres"
const edad = 23
const objeto = {
    nombre: nombre, 
    edad: edad
}
objeto // { nombre: 'Andres', edad: 23 }

Cómo utilizar objetos literales
Con los parámetros de objeto puedes obviar la repetición de nombres, JavaScript creará la propiedad a partir del nombre de la variable con su respectivo valor.
const nombre = "Andres"
const edad = 23
const objeto = {nombre, edad}
objeto // { nombre: 'Andres', edad: 23 }

El resultado es el mismo, pero sin la necesidad de repetir palabras. Puedes combinarlo con variables que su propiedad tiene un nombre diferente.
const nombre = "Andres"
const edad = 23
const esteEsUnID = 1
const objeto = {
    nombre, 
    edad,
    id: esteEsUnID
}
objeto // { nombre: 'Andres', edad: 23, id: 1 }

ES6: promesas
Una promesa es una forma de manejar el asincronismo en JavaScript y se representa como un objeto que puede generar un valor único a futuro, que tiene dos estados, o está resuelta o incluye una razón por la cual no ha sido resuelta la solicitud.

Cómo utilizar las promesas
Solamente ten presente que la clase Promise y sus métodos then y catch fueron añadidos en ES6. Esto resuelve un problema del manejo del asincronismo con callbacks, llamado Callback Hell.
El argumento de la clase Promise es una función que recibe dos parámetros:
resolve: cuando la promesa es resuelta.
reject: cuando la promesa es rechazada.
Puedes utilizar cualquier nombre, siempre y cuando sepas su funcionamiento.

Esto de las promesas se usar principalmente cuando se pide un dato y aun no ha pasado el tiempo para que suceda por ejemplo:
const datos=[{
id:1,
title:'Iron',
year:2000
},{
id:2,
title:'Iron',
year:2000
},{
id:3,
title:'Iron',
year:2000
}];
const getDatos = () =>{
setTimeout(()=>{
return datos;
},1500);
}
console.log(getDatos()) //undefined, devolvio eso porque no hubo nada que hiciera que esperara a que getDatos() se terminara de ejecutar o esperarlo.
PARA resolver el problema anterior se usa el Promise:
"then()" es para cuando se resuelva.
A continuacion hasta que no espere 1500 ms no se ejecutara la funcion para ello es el promise:
const datos=[{
id:1,
title:'Iron',
year:2000
},{
id:2,
title:'Iron',
year:2000
},{
id:3,
title:'Iron',
year:2000
}];
const getDatos = () =>{
return new Promise((resolve, reject)=>{
setTimeout(()=>{
  resolve(datos);
},1500);
});
}
getDatos()
    .then((datos)=>console.log(datos)) //imprimira el objeto datos, pueden haber varios then()
    .catch(error => console.log('hubo un error')) //En caso que se ejecute reject
    //catch es para cuando hay un error

otro ejemplo de promise:
const promesa = () => {
  return new Promise((resolve, reject) => {
    if (true) {
      //true o false
      resolve("Se ha resuelto la promesa")
    } else {
      reject("Se ha rechazado la promesa")
    }
  })
}
promesa()
  .then(respuesta => console.log(respuesta)) //En caso que se ejecute resolve
  .catch(error => console.log(error)) //En caso que se ejecute reject
// output: Se ha resuelto la promesa
Ahora con false
const promesa = () => {
  return new Promise((resolve, reject) => {
    if (false) {
      //true o false
      resolve("Se ha resuelto la promesa")
    } else {
      reject("Se ha rechazado la promesa")
    }
  })
}
promesa()
  .then(respuesta => console.log(respuesta)) //En caso que se ejecute resolve
  .catch(error => console.log(error)) //En caso que se ejecute reject
// output: Se ha rechazado la promesa

ES6: clases
class User{};//se dejara la clase
const newUser=new User();//se crea una instancia de una clase
class user {
    //metodos
    greeting(){
        return 'Hello';
    }
};
const gndx=new user();//se crea una instancia de una clase
console.log(gndx.greeting())
const bebeloper=new user()
console.log(bebeloper.greeting())
//constructor
class user{
    //constructor
    constructor(){
        console.log("Nuevo Usuario");
    }
    greeting(){
        return 'Hello';
    }
}
const david=new user(); //Nuevo Usuario , ya que el constructor inicializa los elementos

//this
class user{
    //constructor
    constructor(name){
        this.name=name;
    }
    //metodos
    speak(){
        return 'Hello'
    }
    greeting(){
        return `${this.speak()} ${this.name}`;
    }
}
const ana=new user('Ana');
console.log(ana.greeting()) // Helo Ana

// setters getters
class user{
    //constructor
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    //metodos
    speak(){
        return 'Hello'
    }
    greeting(){
        return `${this.speak()} ${this.name}`;
    }
    get uAge(){
        return this.age;
    }
    set uAge(n){
        this.age=2*n;
    }
}
const bebe=new user('David',15); //'David' y 15 van al constructor
console.log(bebe.uAge) // 15
console.log(bebe.uAge=20) // 20, como se hace bebe.uAge=20, entra por set uAge(n), this.age=n, luego va a get uAge() pero en un proximo. 
console.log(bebe.uAge) // 20, en este casi cambio el valor debido a la linea anterior.

ES6: module
Para que el código de JavaScript sea más ordenado, legible y mantenible; ES6 introduce una forma de manejar código en archivos de manera modular. Esto involucra exportar funciones o variables de un archivo, e importarlas en otros archivos donde se necesite.

Cómo utilizar los módulos de ECMAScript
Para explicar cómo funciona las exportaciones e importaciones de código, debes tener mínimo dos archivos, uno para exportar las funcionalidades y otro que las importe para ejecutarlas.
Además, si iniciaste un proyecto con NPM (Node Package Manager) con Node.js, necesitas especificar que el código es modular en el archivo package.json de la siguiente manera:
// package.json
{   ...
    "type": "module"
}
//tambien en html con: <script type="m" src=""></script>

Qué son las exportaciones de código
Las exportaciones de código consisten en crear funciones o variables para utilizarlas en otros archivos mediante la palabra reservada export.
Existen dos formas de exportar, antes de declarar la funcionalidad, o entre llaves {}.
Por ejemplo, en el archivo math_function.js declaramos una función para sumar dos valores, el cual lo exportaremos.
//math_function.js.. 1) forma
export const add = (x,y) => {
    return x + y
}
//math_function.js. 2) forma
const add = (x,y) => {
    return x + y
}
export { add, otherFunction, ... }

Qué son las importaciones de código
Las importaciones de código consiste en usar funciones o variables de otros archivos mediante la palabra reservada import, que deberán estar siempre lo más arriba del archivo y utilizando el mismo nombre que el archivo original.
Existen dos formas de exportar, antes de declarar la funcionalidad, o entre llaves {}.
Por ejemplo, importamos la función add del archivo math_function.js para utilizarla en un archivo main.js.
// main.js. 1) forma
import { add, otherFunction } from './math_functions.js'
add(2,2) //4
Si importamos el módulo con un nombre diferente, existirá un error de sintaxis.
// Erróneo
import { suma } from './math_functions.js'
suma(2,2) //SyntaxError: The requested module '/src/archivo1.js' does not provide an export named 'suma'

Para importar todas las funcionalidades de un archivo se utiliza un asterisco (*) y se puede cambiar el nombre para evitar la repetición de variables o funciones a través de la palabra reservada as.
// main.js
import * as myMathModule from './math_functions.js';
myMathModule.add(2,2) //4
myMathModule.otherFunction()
...

Exportaciones por defecto
Si solo UN valor será exportado, entonces se puede utilizar export default. De esta manera no es necesario las llaves {} al exportar e importar.
//math_function.js
export default function add (x,y){
    return x + y;
}

Adicionalmente, no se puede usar export default antes de declaraciones const, let o var, pero puedes exportarlas al final.
// ❌ Erróneo
export default const add  = (x,y) => {
    return x + y;
}
// ✅ Correcto
const add  = (x,y) => {
    return x + y;
}
export default add

Importaciones por defecto
Si únicamente un valor será importado, entonces se puede utilizar cualquier nombre en la importación. De esta manera no es necesario las llaves {}.
//Las siguientes importaciones son válidas
import  add  from './math_functions.js'
import  suma  from './math_functions.js'
import  cualquierNombre  from './math_functions.js'

Sin embargo, es recomendable utilizar siempre el nombre de la función, para evitar confusiones.

Combinar ambos tipos de exportaciones e importaciones
Teniendo las consideraciones de importaciones y exportaciones, nombradas y por defecto, entonces podemos combinarlas en un mismo archivo.
// module.js
export const myExport = "hola"
function myFunction() { ... }
export default myFunction
// main.js
import myFunction, { myExport } from "/module.js"

EJERCICIO:
En este desafío tendrás un archivo llamado api.js que estará al mismo nivel que tu archivo exercise.js.
Este archivo tendrá una función asíncrona getData() que te retornará una lista de resultados misteriosa.
Tu función solution() deberá retornar la misma lista de resultados que te brinda la función getData().
Input:
solution();
Ouput:
[{
    movie: "El despertar de los michis",
    year: 2021,
    protagonist: "Mr. Michi"
}, {
    movie: "101 Michis",
    year: 2019,
    protagonist: "Tommy Michiguire"
}]
RTA: 
//en este caso el import se hace con { } porque no se hizo el export default getData en el archivo api.js. Si se hubiera hecho, simplemente sería, import getData from “./api.js”;
//api.js
export async function getData() {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve([{
                movie: "El despertar de los michis",
                year: 2021,
                protagonist: "Mr. Michi"
            }, {
                movie: "101 Michis",
                year: 2019,
                protagonist: "Tommy Michiguire"
            }]);
        }, 1000);
    });
}
//exercise.js
import { getData } from "./api.js";

export function solution() {
  // Tu código aquí 👈
  return getData();
}
OUTPUT:
[{"movie":"El despertar de los michis","year":2021,"protagonist":"Mr. Michi"},{"movie":"101 Michis","year":2019,"protagonist":"Tommy Michiguire"}]

funcion asincrona "async", siempre devuelven una promesa:  
Las funciones asíncronas son útiles cuando se realiza una tarea que puede tardar un tiempo en completarse, como hacer una solicitud a un servidor. En lugar de bloquear la ejecución del código hasta que se complete la tarea, se puede utilizar una función asíncrona para que la tarea se ejecute en segundo plano y el resto del código siga ejecutándose mientras tanto.
ejemplo:
async function miFuncionAsincrona() {
  // Hacer una solicitud a un servidor
  const resultado = await fetch('https://mi-servidor.com/datos');
  // Hacer algo con los datos obtenidos de la solicitud
  console.log(resultado);
  // Devolver un valor
  return resultado;
}
**la función miFuncionAsincrona utiliza la palabra clave async
**hace una solicitud a un servidor utilizando la función fetch
**await se utiliza para esperar a que se resuelva la promesa y obtener el resultado de la solicitud.

ES6: generator.
Los generadores son funciones especiales que pueden pausar su ejecución, luego volver al punto donde se quedaron, recordando su scope y seguir retornando valores.
Estos se utilizan para guardar la totalidad de datos infinitos, a través de una función matemática a valores futuros. De esta manera ocupan poca memoria, con respecto a si creamos un array u objeto.

Cómo utilizar generadores
La sintaxis de los generadores comprende lo siguiente:

La palabra reservada function* (con el asterisco al final).
La palabra reservada yield que hace referencia al valor retornado cada vez que se invoque, recordando el valor anterior.
Crear una variable a partir de la función generadora.
El método next devuelve un objeto que contiene una propiedad value con cada valor de yield; y otra propiedad done con el valor true o false si el generador ha terminado.
Si el generador se lo invoca y ha retornado todos sus valores de yield, entonces devolverá el objeto con las propiedades value con undefined y un done con true.

// Declaración
function* nombre(parámetros){
    yield (primer valor retornado)
    yield (segundo valor retornado)
    ...
    yield (último valor retornado)

}

//Crear el generador
const generador = nombre(argumentos)

// Invocacioens
generador.next().value //primer valor retornado
generador.next().value //segundo valor retornado
...
generador.next().value //último valor retornado

Ejemplo de un generador
Por ejemplo, creemos un generador para retornar tres valores.
function* generator(){
    yield 1
    yield 2
    yield 3
}

const generador = generator()

generador.next().value //1
generador.next().value //2
generador.next().value //3
generador.next() // {value: undefined, done: true}

documentacion generadores: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Generator

Cómo utilizar for of (para el valor) y for in (para el index o llave)
Existen dos nuevas formas de utilizar ciclos repetitivos. El bucle for valor of iterable recorre iterables, como arrays, Map, Set e incluso un generador.

El valor es cada elemento del iterable puede tener cualquier nombre, por eso se inicia con let nombre.

const array = [5, 4, 3, 2, 1]

for (let numero of array) {
  console.log(numero) // 5 4 3 2 1
}

Sin embargo, debes tener en cuenta que solo podrás acceder a sus valores, y no a sus referencias, por lo que si quieres cambiar los elementos del array, necesitarás un índice array[indice].

for (let numero of array) {
  valor *= 2 //esto es igual a valor=valor*2
  console.log(numero) // 10 8 6 4 2
}
 
console.log(array) // [ 5, 4, 3, 2, 1 ]

Si intentas recorrer un objeto de esta forma for elemento of objeto, te ocurrirá un error, porque un objeto no es un iterable. En su lugar puedes utilizar for elemento in objeto, que recorrerá las propiedades del objeto.
const objeto = { a: 1, b: 2, c: 3 }

for (let elemento in objeto) {
  console.log(elemento) // 'a' 'b' 'c'
}

Sin embargo, si utilizas for elemento in array, no dará un error, pero el resultado no será el esperado, ya que los arrays son un tipo de objeto donde cada propiedad es el índice del valor del array o del iterable. Por lo que debes tener cuidado.
const array = [5, 4, 3, 2, 1]

for (let elemento in array) {
  console.log(elemento) // '0' '1' '2' '3' '4'
}

/* const array = {
	'0': 5,
  '1': 4,
  '2': 3,
  '3': 2,
  '4': 1
}*/











</code></pre>

</div>

</body>
</html>
