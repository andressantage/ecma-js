<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CampusLand</title>
    <link rel="stylesheet" href="prism.css">
    <link rel="shortcut icon" href="img/logo.png" type="image/x-icon">
	<script src="prism.js"></script>
    <style>
body{
    background-color: black;
}
.cuadro{
    display: flex;
    justify-content: center;
}
    </style>
</head>
<body>
<h1>ECMA</h1>
    <div class="cuadro">
<pre><code class="language-javascript">
ECMAScript:
es un estandar para lenguaje de programacion. ya que fue regulado inicialmente}
por la ECMA. Versiones de javascript

TC39:
grupo de desarrolladores que estan a cargo de revisar cada propuesta o 
funcionalidad que cumpla con el estandar

ESNext es un nombre que siempre indica la pr√≥xima versi√≥n de javascript y esto consta de los siguientes pasos:

    Stage0: Strawperson (borrador, cualquier persona puede tener una idea para implementar en el estandar)

    Stage1: Proposal (propuesta formal)

    Stage2: Draft (borrador, como va a funcionar la implementacion el impacto entre otros)

    Stage3: Candidate (se elige el candidato, vamos a tener una propuesta que va ayudar a mejorar el lenguaje.)

    Stage4: Finished (va a ser desplegada en la version normalmente en JUNIO)

ES6 o ES2015:
nueva declaracion de variables:
let, const
nuevas funciones:
funciones flechas

Las nuevas palabras reservadas let y const resuelven varios problemas con var como el scope, hoisting, variables globales, re-declaraci√≥n y re-asignaci√≥n de variables.

Variables re-declaradas y re-asignadas
La re-declaraci√≥n es volver a declarar una variable, y la re-asignaci√≥n es volver a asignar un valor
*Una variable declarada con var puede ser re-declarada y re-asignada.
*Una variable declarada con let puede ser re-asignada, pero no re-declarada.
*Una variable declarada con const no puede ser re-declarada, ni re-asignada. Su declaraci√≥n y asignaci√≥n debe ser en una l√≠nea, caso contrario habr√° un error.
En conclusi√≥n, si intentas re-declarar una variable declarada con let y const habr√° un error de ‚Äúvariable ya declarada‚Äù; por otro lado, si intentas re-asignar una variable declarada con const existir√° un ‚Äúerror de tipo‚Äù.

"dejar de utilizar var"

// Declaraci√≥n de variables
var nameVar
let nameLet

// Asignaci√≥n de variables
nameVar= "soy var"
nameLet = "soy let"

Aunque realmente lo que pasa si no asignas un valor en la declaraci√≥n, JavaScript le asigna un valor undefined.

//siempre asignar con const un valor a la varuable
const pi  // SyntaxError: Missing initializer in const declaration.

Ejemplo de re-declaraci√≥n de variables:
var nameVar = "soy var"
let nameLet = "soy let"
const nameConst = "soy const"
// Re-declaraci√≥n de variables
var nameVar = "var soy"
console.log(nameVar) // 'var soy'
let nameLet = "let soy" // SyntaxError: Identifier 'nameLet' has already been declared.
const nameConst = "const soy" //SyntaxError: Identifier 'nameConst' has already been declared.

Ejemplo de re-asignaci√≥n de variables:
var nameVar = "soy var"
let nameLet = "soy let"
const nameConst = "soy const"
// Re-asignaci√≥n de variables
nameVar = "otro var"
console.log(nameVar) // 'otro var'
nameLet = "otro let"
console.log(nameVar) // otro let'
nameConst = "otro const" //TypeError: Assignment to constant variable.

Scope
En el tema del scope, let y const tienen un scope de bloque y var no.
ejemplo:
{
var nameVar = "soy var"
let nameLet = "soy let"
}
console.log(nameVar) // 'soy var'
console.log(nameLet) // ReferenceError: nameLet is not defined

Objeto global
En variables globales, let y const no guardan sus variables en el objeto global (window, global o globalThis), mientras que var s√≠ los guarda.
var nameVar = "soy var"
let nameLet = "soy let"
const nameConst = "soy const"

globalThis.nameVar   // 'soy var'
globalThis.nameLet   // undefined
globalThis.nameConst  // undefined

Funciones flecha

Las funciones flecha (arrow functions) consiste en una funci√≥n an√≥nima con la siguiente estructura:
//Funci√≥n tradicional
function nombre (par√°metros) {
    return valorRetornado
}
//Funci√≥n flecha
const nombre = (par√°metros) => {
    return valorRetornado
}

Se denominan funci√≥n flecha por el elemento => en su sintaxis.

Omitir par√©ntesis en las funciones flecha:
Si existe un solo par√°metro, puedes omitir los par√©ntesis.
const porDos = num => {
    return num * 2
}

Retorno impl√≠cito
Las funciones flecha tienen un retorno impl√≠cito, es decir, se puede omitir la palabra reservada return, para que el c√≥digo sea escrito en una sola l√≠nea.
//Funci√≥n tradicional
function suma (num1, num2) {
    return num1 + num2
}
//Funci√≥n flecha
const suma = (num1, num2) => num1 + num2

Si el retorno requiere de m√°s l√≠neas y a√∫n deseas utilizarlo de manera impl√≠cita, deber√°s envolver el cuerpo de la funci√≥n entre par√©ntesis.
const suma = (num1, num2) => (
    num1 + num2
)
const suma = num1=>num1*3

//funcion anonima:
const suma = (num1, num2) => num1 + num2
suma(2,3)//5

ES6: strings
Las plantillas literales (template literals) consisten en crear cadenas de caracteres que puedan contener variables sin utilizar la concatenaci√≥n. Esto mejora la legibilidad y la mantenibilidad del c√≥digo.

Concatenaci√≥n de caracteres
Antes de ES6, si quer√≠as crear una cadena larga o un mensaje elaborado, deb√≠as utilizar la concatenaci√≥n. La concatenaci√≥n de caracteres consiste en unir uno o varios caracteres, como si fuera una suma.
var nombre = "Andres"
var edad = 23
var mensaje = "Mi nombre es " + nombre + " y tengo " + edad + " a√±os."
console.log(mensaje) // 'Mi nombre es Andres y tengo 23 a√±os.'

Esto trae varios problemas en la legibilidad y mantenibilidad del c√≥digo. Se convierte cada vez m√°s complejo en mensajes m√°s extensos o el estar pendiente de agregar espacios antes o despu√©s de cada variable concatenada.

C√≥mo utilizar las plantillas literales
Las plantillas literales a√±adidas en ES6, se emplea el caracter acento grave ( ` ), que no es una comilla simple ( ‚Äô ), para envolver el mensaje. Para incluir las variables se utiliza la sintaxis ${variable}.
var nombre = "Andres"
var edad = 23
var mensaje = `Mi nombre es ${nombre} y tengo ${edad} a√±os.`
console.log(mensaje) // 'Mi nombre es Andres y tengo 23 a√±os.'

De esta manera el c√≥digo es m√°s legible y que pueda mantenerse.

Plantilla multil√≠nea
La plantilla multil√≠nea consiste en crear mensajes que contengan varias l√≠neas separadas entre s√≠, utilizando las plantillas literales. Antes de ES6, la forma de crear una plantilla multil√≠nea era agregar \n al string.
var mensaje = "L√≠nea 1 \n" + "l√≠nea 2"
console.log(mensaje)
// 'L√≠nea 1
// l√≠nea 2'

Con ES6 solamente necesitas utilizar las plantillas literales.
const mensaje = `L√≠nea 1
l√≠nea 2`
console.log(mensaje)
// 'L√≠nea 1
// l√≠nea 2'

ES6: par√°metros por defecto
Los par√°metros por defecto (default params) consisten en establecer un valor por defecto a los par√°metros de una funci√≥n, para asegurar que el c√≥digo se ejecute correctamente en el caso de que no se establezcan los argumentos correspondientes en la invocaci√≥n de la funci√≥n.

C√≥mo era utilizar valores por defecto antes de ES6
Tal como puedes ver en el siguiente c√≥digo, la funci√≥n sumar recibe dos par√°metros y retorna el valor total. Sin embargo, si alguien no decide poner alguno o todos los par√°metros necesarios, pues que el programa no funcionar√° correctamente.
function sumar(number1, number2){
  return number1 + number2
}
sumar(3,4) // 7
sumar(3)   // NaN  
sumar()    // NaN

Antes de ES6, se deb√≠a establecer una variable y utilizar el operador OR ( ||) con el valor por defecto necesario. El caracter guion bajo ( _) lo utilizo para diferenciar el par√°metro de la funci√≥n de la variable declarada.
function sumar(number1, number2){
  var _number1 = number1 || 0
  var _number2 = number2 || 0
 
  return _number1 + _number2
}
sumar(3,4) // 7
sumar(3)   // 3
sumar()    // 0

Puedes utilizar cualquier valor, siempre que sea necesario.

Posici√≥n de los par√°metros por defecto
Si obligatoriamente necesitas el valor como argumento, ten presente que los par√°metros por defecto siempre deben estar en las posiciones finales.
// ‚ùå Mal
function sumar(number1 = 0, number2) { //proceso% }
sumar(3)   // number1 = 3 y number2 = undefined
// ‚úÖ Bien
function sumar(number1, number2 = 0) { //proceso% }
sumar(3)   // number1 = 3 y number2 = 0

otra forma:
both argument are passed
sum(5,15);
function sum(x=3,y=5){
    return x+y;
}
one argument is passed
sum(7);//aqui tomar solo el valor de x=7
function sum(x=3,y=5){
    return x+y;
}
no argument is passed
sum();//x=3, y=5
function sum(x=3,y=5){
    return x+y;
}

ES6: asignaci√≥n de desestructuraci√≥n
La desestructuraci√≥n (destructuring) consiste en extraer los valores de arrays o propiedades de objetos en distintas variables.

Desestructuraci√≥n de objetos
La desestructuraci√≥n de objetos implica extraer las propiedades de un objeto en variables. Mediante el mismo nombre de la propiedad del objeto con la siguiente sintaxis:
const objeto = {
    prop1: "valor1",
    prop2: "valor2",
}
// Desestructuraci√≥n
const { prop1, prop2 } = objeto// AQUI EN ESTE CASO PROP1 DEBE LLAMARSE IGUAL A LA LLAVE DEL OBJETO SI O SI.
console.log(prop1) //valor1  //LO DE LA LLAVE DEL OBJETO SE GUARDA EN prop1
console.log(prop1) //valor2

Antes de ES6, necesitabas acceder al objeto con la notaci√≥n punto o corchetes por cada propiedad que se necesita y asignar ese valor a una variable diferente.
var usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
var nombre = usuario.nombre
var edad = usuario.edad
var plataforma = usuario["plataforma"]
console.log(nombre)  // 'Andres'
console.log(edad)  // 23
console.log(plataforma)  // 'Platzi'

Con la desestructuraci√≥n puedes realizar lo mismo, pero en una sola l√≠nea, provocando que el c√≥digo seas m√°s legible y mantenible.
const usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
const { nombre, edad, plataforma } = usuario
console.log(nombre)  // 'Andres'
console.log(edad)  // 23
console.log(plataforma)  // 'Platzi'

Cambiar el nombre de las variables con desestructuraci√≥n
Si no te agrada el nombre de la propiedad del objeto, puedes cambiarlo utilizando la siguiente sintaxis:
const objeto = { prop1: "valor1", prop2: "valor2" }
// Desestructuraci√≥n
const { prop1: newProp1, prop2: newProp2 } = objeto
console.log(prop1)  // GENERA ERROR: prop1 is not defined
console.log(newProp1)  // valor1

Por ejemplo:
const usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
const { nombre: name, edad: age, plataforma: platform } = usuario
console.log(name)  // 'Andres'
console.log(age)  // 23
console.log(platform)  // 'Platzi'
console.log(nombre)   // Uncaught ReferenceError: nombre is not defined

Desestructuraci√≥n en par√°metros de una funci√≥n
Si env√≠as un objeto como argumento en la invocaci√≥n a la declaraci√≥n de una funci√≥n, puedes utilizar la desestructuraci√≥n en los par√°metros para obtener los valores directamente. Ten en cuenta que el nombre debe ser igual a la propiedad del objeto.
const usuario = { nombre: "Andres", edad: 23, plataforma: "Platzi" }
function mostrarDatos( { nombre, edad, plataforma } ){
    console.log(nombre, edad, plataforma)
}
mostrarDatos(usuario) // 'Andres', 23, 'Platzi'

Desestructuraci√≥n de arrays
La desestructuraci√≥n de arrays consiste en extraer los valores de un array en variables, utilizando la misma posici√≥n del array con una sintaxis similar a la desestructuraci√≥n de objetos.
const array = [ 1, 2, 3, 4, 5 ]
// Desestructuraci√≥n
const [uno, dos, tres ] = array
console.log(uno) // 1
console.log(dos) // 2
console.log(tres) // 3

Desestructuraci√≥n para valores retornados de una funci√≥n
Cuando una funci√≥n retorna un array, puedes guardarlo en una variable. Por ende, puedes utilizar la desestructuraci√≥n para utilizar esos valores por separado de manera legible.

En el siguiente ejemplo, la funci√≥n useState retorna un array con dos elementos: un valor y otra funci√≥n actualizadora.
=> (funci√≥n useState) (value es el valor, updateValue() es la funcion actualizadora) retorna un array con dos elementos: un valor y otra funci√≥n actualizadora.
function updateValue(value){
return value*2
}
function useState(value){
    return [value, updateValue(value)]
}
//Sin desestructuraci√≥n
const estado = useState(3)
const valor = estado[0]
const actualizador = estado[1]
//Con desestructuraci√≥n
const [valor, actualizador] = useState(3)

Lo que puedes hacer con desestructuraci√≥n, pero no es recomendable
Si necesitas un elemento en cierta posici√≥n, puedes utilizar la separaci√≥n por comas para identificar la variable que necesitas.
const array = [ 1, 2, 3, 4, 5 ]
const [ ,,,,  cinco ] = array
console.log(cinco) // 5

Como los arrays son un tipo de objeto, puedes utilizar la desestructuraci√≥n de objetos mediante el √≠ndice y utilizando un nombre para la variable.
const array = [ 1, 2, 3, 4, 5 ]
const {4: cinco} = array //{indice_lista(4): variable_en_el_array}
console.log(cinco) // 5

ES6: spread operator
El operador de propagaci√≥n (spread operator), como su nombre lo dice, consiste en propagar los elementos de un iterable, ya sea un array o string utilizando tres puntos (...) dentro de un array.
// Para strings
const array = [ ..."Hola"]    // [ 'H', 'o', 'l', 'a' ]
// En arrays
const otherArray = [ ...array]   //[ 'H', 'o', 'l', 'a' ]
Tambi√©n se utiliza para objetos, pero esta caracter√≠stica fue a√±adida en versiones posteriores de ECMAScript y es denominada propiedades de propagaci√≥n.

C√≥mo copiar arrays utilizando el operador de propagaci√≥n
Para realizar una copia de un array, deber√°s tener cuidado de la referencia en memoria. Los arrays se guardan en una referencia en la memoria del computador, al crear una copia, este tendr√° la misma referencia que el original. Debido a esto, si cambias algo en la copia, tambi√©n lo har√°s en el original.
const originalArray = [1,2,3,4,5]
const copyArray = originalArray
copyArray[0] = 0
originalArray // [0,2,3,4,5]
originalArray === copyArray  // true

Para evitar esto, utiliza el operador de propagaci√≥n para crear una copia del array que utilice una referencia en memoria diferente al original.
const originalArray = [1,2,3,4,5]
const copyArray = [...originalArray]
copyArray[0] = 0
originalArray // [1,2,3,4,5]
copyArray // [0,2,3,4,5]
originalArray === copyArray  // false

C√≥mo unir arrays y a√±adir elementos con el operador de propagaci√≥n
Para unir dos arrays con el operador de propagaci√≥n, simplemente debes separarlos por comas en un array.
const array1 = [1,2,3]
const number = 4
const array2 = [5,6,7]
const otherArray = [ ...array1, number, ...array2 ]
otherArray // [1,2,3,4,5,6,7]

Cuidado con la copia en diferentes niveles de profundidad
El operador de propagaci√≥n sirve para producir una copia en un solo nivel de profundidad, esto quiere decir que si existen objetos o arrays dentro del array a copiar. Entonces los sub-elementos en cada nivel, tendr√°n la misma referencia de memoria en la copia y en el original.
const originalArray = [1, [2,3] ,4,5]
const copyArray = [...originalArray] 
originalArray[1] === copyArray[1] // true, esto es por tener array dentro de un array debido al nivel de profundidad

solucion al problema anterior:
La manera de solucionar es m√°s compleja, tendr√≠as que emplear el operador de propagaci√≥n para cada elemento en cada nivel de profundidad.
Sin embargo, recientemente sali√≥ una forma de producir una copia profunda con StructuredClone, aunque es una caracter√≠stica muy reciente, as√≠ que revisa que navegadores tienen soporte.
const originalArray = [1, [2,3] ,4,5]
const copyArray = structuredClone(originalArray)
originalArray === copyArray  // false
originalArray[1] === copyArray[1] // false

Este comportamiento tambi√©n sucede para objetos dentro de otros objetos, u objetos dentro de arrays.

Par√°metro rest
El par√°metro rest consiste en agrupar el residuo de elementos mediante la sintaxis de tres puntos (...) seguido de una variable que contendr√° los elementos en un array.
Esta caracter√≠stica sirve para crear funciones que acepten cualquier n√∫mero de argumentos para agruparlos en un array.

function hola (primero, segundo, ...resto) {
  console.log(primero, segundo)  // 1 2
  console.log(resto) // [3,4,5,6]
}
hola(1,2,3,4,5)

Tambi√©n sirve para obtener los elementos restantes de un array u objeto usando desestructuraci√≥n.
const objeto = {
  nombre: "Andres",
  age: 23,
  plataforma: "Platzi"
}
const array = [0,1,2,3,4,5]
const {plataforma, ...usuario} = objeto
const [cero, ...positivos] = array
usuario // { nombre: 'Andres', age: 23 }
positivos // [ 1, 2, 3, 4, 5 ]

Posici√≥n del par√°metro rest
El par√°metro rest siempre deber√° estar en la √∫ltima posici√≥n de los par√°metros de la funci√≥n, caso contrario existir√° un error de sintaxis.
// ‚ùå Mal
function hola (primero, ...rest, ultimo) { ... }
// SyntaxError: Rest element must be last element. 

Diferencias entre el par√°metro rest y el operador de propagaci√≥n
Aunque el par√°metro rest y el operador de propagaci√≥n utilicen la misma sintaxis, son diferentes.
El par√°metro rest agrupa el residuo de elementos y siempre debe estar en la √∫ltima posici√≥n, mientras que el operador de propagaci√≥n expande los elementos de un iterable en un array y no importa en que lugar est√© situado.
"operador de propagaci√≥n expande los elementos de un iterable en un array" expandirlos seria: pasar de [1,2,3,4,5] a 1,2,3,4,5
"rest agrupa el residuo de elementos y siempre debe estar en la √∫ltima posici√≥n"
const array = [1,2,3,4,5]
function hola (primero, segundo, ...resto) { // <- Par√°metro Rest
  console.log(primero, segundo)  // 1 2
  console.log(resto) // [3,4,5, "final"]
}
hola(...array, "final") //<- Operador de propagaci√≥n //Lo mismo que hacer -> hola(1,2,3,4,5, "final")

ejercicio:
function solution(
  json1 = {
    name: "Mr. Michi",
    food: "Pescado"
  },
  json2 = {
    age: 12,
    color: "Blanco"
  }) {
 return { ...json1, ...json2}
}
//entrada:
solution({
    name: "Bigotes",
    food: "Pollito"
})
//salida:
{
    name: "Bigotes",
    food: "Pollito",
    age: 12,
    color: "Blanco"
}

ES6: object literals
Los objetos literales consiste en crear objetos a partir de variables sin repetir el nombre. Antes de ES6, para crear un objeto a partir de variables consist√≠a en la siguiente manera:
const nombre = "Andres"
const edad = 23
const objeto = {
    nombre: nombre, 
    edad: edad
}
objeto // { nombre: 'Andres', edad: 23 }

C√≥mo utilizar objetos literales
Con los par√°metros de objeto puedes obviar la repetici√≥n de nombres, JavaScript crear√° la propiedad a partir del nombre de la variable con su respectivo valor.
const nombre = "Andres"
const edad = 23
const objeto = {nombre, edad}
objeto // { nombre: 'Andres', edad: 23 }

El resultado es el mismo, pero sin la necesidad de repetir palabras. Puedes combinarlo con variables que su propiedad tiene un nombre diferente.
const nombre = "Andres"
const edad = 23
const esteEsUnID = 1
const objeto = {
    nombre, 
    edad,
    id: esteEsUnID
}
objeto // { nombre: 'Andres', edad: 23, id: 1 }

ES6: promesas
Una promesa es una forma de manejar el asincronismo en JavaScript y se representa como un objeto que puede generar un valor √∫nico a futuro, que tiene dos estados, o est√° resuelta o incluye una raz√≥n por la cual no ha sido resuelta la solicitud.

C√≥mo utilizar las promesas
Solamente ten presente que la clase Promise y sus m√©todos then y catch fueron a√±adidos en ES6. Esto resuelve un problema del manejo del asincronismo con callbacks, llamado Callback Hell.
El argumento de la clase Promise es una funci√≥n que recibe dos par√°metros:
resolve: cuando la promesa es resuelta.
reject: cuando la promesa es rechazada.
Puedes utilizar cualquier nombre, siempre y cuando sepas su funcionamiento.

Esto de las promesas se usar principalmente cuando se pide un dato y aun no ha pasado el tiempo para que suceda por ejemplo:
const datos=[{
id:1,
title:'Iron',
year:2000
},{
id:2,
title:'Iron',
year:2000
},{
id:3,
title:'Iron',
year:2000
}];
const getDatos = () =>{
setTimeout(()=>{
return datos;
},1500);
}
console.log(getDatos()) //undefined, devolvio eso porque no hubo nada que hiciera que esperara a que getDatos() se terminara de ejecutar o esperarlo.
PARA resolver el problema anterior se usa el Promise:
"then()" es para cuando se resuelva.
A continuacion hasta que no espere 1500 ms no se ejecutara la funcion para ello es el promise:
const datos=[{
id:1,
title:'Iron',
year:2000
},{
id:2,
title:'Iron',
year:2000
},{
id:3,
title:'Iron',
year:2000
}];
const getDatos = () =>{
return new Promise((resolve, reject)=>{
setTimeout(()=>{
  resolve(datos);
},1500);
});
}
getDatos()
    .then((datos)=>console.log(datos)) //imprimira el objeto datos, pueden haber varios then()
    .catch(error => console.log('hubo un error')) //En caso que se ejecute reject
    //catch es para cuando hay un error

otro ejemplo de promise:
const promesa = () => {
  return new Promise((resolve, reject) => {
    if (true) {
      //true o false
      resolve("Se ha resuelto la promesa")
    } else {
      reject("Se ha rechazado la promesa")
    }
  })
}
promesa()
  .then(respuesta => console.log(respuesta)) //En caso que se ejecute resolve
  .catch(error => console.log(error)) //En caso que se ejecute reject
// output: Se ha resuelto la promesa
Ahora con false
const promesa = () => {
  return new Promise((resolve, reject) => {
    if (false) {
      //true o false
      resolve("Se ha resuelto la promesa")
    } else {
      reject("Se ha rechazado la promesa")
    }
  })
}
promesa()
  .then(respuesta => console.log(respuesta)) //En caso que se ejecute resolve
  .catch(error => console.log(error)) //En caso que se ejecute reject
// output: Se ha rechazado la promesa

ES6: clases
class User{};//se dejara la clase
const newUser=new User();//se crea una instancia de una clase
class user {
    //metodos
    greeting(){
        return 'Hello';
    }
};
const gndx=new user();//se crea una instancia de una clase
console.log(gndx.greeting())
const bebeloper=new user()
console.log(bebeloper.greeting())
//constructor
class user{
    //constructor
    constructor(){
        console.log("Nuevo Usuario");
    }
    greeting(){
        return 'Hello';
    }
}
const david=new user(); //Nuevo Usuario , ya que el constructor inicializa los elementos

//this
class user{
    //constructor
    constructor(name){
        this.name=name;
    }
    //metodos
    speak(){
        return 'Hello'
    }
    greeting(){
        return `${this.speak()} ${this.name}`;
    }
}
const ana=new user('Ana');
console.log(ana.greeting()) // Helo Ana

// setters getters
class user{
    //constructor
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    //metodos
    speak(){
        return 'Hello'
    }
    greeting(){
        return `${this.speak()} ${this.name}`;
    }
    get uAge(){
        return this.age;
    }
    set uAge(n){
        this.age=2*n;
    }
}
const bebe=new user('David',15); //'David' y 15 van al constructor
console.log(bebe.uAge) // 15
console.log(bebe.uAge=20) // 20, como se hace bebe.uAge=20, entra por set uAge(n), this.age=n, luego va a get uAge() pero en un proximo. 
console.log(bebe.uAge) // 20, en este casi cambio el valor debido a la linea anterior.

ES6: module
Para que el c√≥digo de JavaScript sea m√°s ordenado, legible y mantenible; ES6 introduce una forma de manejar c√≥digo en archivos de manera modular. Esto involucra exportar funciones o variables de un archivo, e importarlas en otros archivos donde se necesite.

C√≥mo utilizar los m√≥dulos de ECMAScript
Para explicar c√≥mo funciona las exportaciones e importaciones de c√≥digo, debes tener m√≠nimo dos archivos, uno para exportar las funcionalidades y otro que las importe para ejecutarlas.
Adem√°s, si iniciaste un proyecto con NPM (Node Package Manager) con Node.js, necesitas especificar que el c√≥digo es modular en el archivo package.json de la siguiente manera:
// package.json
{   ...
    "type": "module"
}
//tambien en html con: <script type="m" src=""></script>

Qu√© son las exportaciones de c√≥digo
Las exportaciones de c√≥digo consisten en crear funciones o variables para utilizarlas en otros archivos mediante la palabra reservada export.
Existen dos formas de exportar, antes de declarar la funcionalidad, o entre llaves {}.
Por ejemplo, en el archivo math_function.js declaramos una funci√≥n para sumar dos valores, el cual lo exportaremos.
//math_function.js.. 1) forma
export const add = (x,y) => {
    return x + y
}
//math_function.js. 2) forma
const add = (x,y) => {
    return x + y
}
export { add, otherFunction, ... }

Qu√© son las importaciones de c√≥digo
Las importaciones de c√≥digo consiste en usar funciones o variables de otros archivos mediante la palabra reservada import, que deber√°n estar siempre lo m√°s arriba del archivo y utilizando el mismo nombre que el archivo original.
Existen dos formas de exportar, antes de declarar la funcionalidad, o entre llaves {}.
Por ejemplo, importamos la funci√≥n add del archivo math_function.js para utilizarla en un archivo main.js.
// main.js. 1) forma
import { add, otherFunction } from './math_functions.js'
add(2,2) //4
Si importamos el m√≥dulo con un nombre diferente, existir√° un error de sintaxis.
// Err√≥neo
import { suma } from './math_functions.js'
suma(2,2) //SyntaxError: The requested module '/src/archivo1.js' does not provide an export named 'suma'

Para importar todas las funcionalidades de un archivo se utiliza un asterisco (*) y se puede cambiar el nombre para evitar la repetici√≥n de variables o funciones a trav√©s de la palabra reservada as.
// main.js
import * as myMathModule from './math_functions.js';
myMathModule.add(2,2) //4
myMathModule.otherFunction()
...

Exportaciones por defecto
Si solo UN valor ser√° exportado, entonces se puede utilizar export default. De esta manera no es necesario las llaves {} al exportar e importar.
//math_function.js
export default function add (x,y){
    return x + y;
}

Adicionalmente, no se puede usar export default antes de declaraciones const, let o var, pero puedes exportarlas al final.
// ‚ùå Err√≥neo
export default const add  = (x,y) => {
    return x + y;
}
// ‚úÖ Correcto
const add  = (x,y) => {
    return x + y;
}
export default add

Importaciones por defecto
Si √∫nicamente un valor ser√° importado, entonces se puede utilizar cualquier nombre en la importaci√≥n. De esta manera no es necesario las llaves {}.
//Las siguientes importaciones son v√°lidas
import  add  from './math_functions.js'
import  suma  from './math_functions.js'
import  cualquierNombre  from './math_functions.js'

Sin embargo, es recomendable utilizar siempre el nombre de la funci√≥n, para evitar confusiones.

Combinar ambos tipos de exportaciones e importaciones
Teniendo las consideraciones de importaciones y exportaciones, nombradas y por defecto, entonces podemos combinarlas en un mismo archivo.
// module.js
export const myExport = "hola"
function myFunction() { ... }
export default myFunction
// main.js
import myFunction, { myExport } from "/module.js"

EJERCICIO:
En este desaf√≠o tendr√°s un archivo llamado api.js que estar√° al mismo nivel que tu archivo exercise.js.
Este archivo tendr√° una funci√≥n as√≠ncrona getData() que te retornar√° una lista de resultados misteriosa.
Tu funci√≥n solution() deber√° retornar la misma lista de resultados que te brinda la funci√≥n getData().
Input:
solution();
Ouput:
[{
    movie: "El despertar de los michis",
    year: 2021,
    protagonist: "Mr. Michi"
}, {
    movie: "101 Michis",
    year: 2019,
    protagonist: "Tommy Michiguire"
}]
RTA: 
//en este caso el import se hace con { } porque no se hizo el export default getData en el archivo api.js. Si se hubiera hecho, simplemente ser√≠a, import getData from ‚Äú./api.js‚Äù;
//api.js
export async function getData() {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve([{
                movie: "El despertar de los michis",
                year: 2021,
                protagonist: "Mr. Michi"
            }, {
                movie: "101 Michis",
                year: 2019,
                protagonist: "Tommy Michiguire"
            }]);
        }, 1000);
    });
}
//exercise.js
import { getData } from "./api.js";

export function solution() {
  // Tu c√≥digo aqu√≠ üëà
  return getData();
}
OUTPUT:
[{"movie":"El despertar de los michis","year":2021,"protagonist":"Mr. Michi"},{"movie":"101 Michis","year":2019,"protagonist":"Tommy Michiguire"}]

funcion asincrona "async", siempre devuelven una promesa:  
Las funciones as√≠ncronas son √∫tiles cuando se realiza una tarea que puede tardar un tiempo en completarse, como hacer una solicitud a un servidor. En lugar de bloquear la ejecuci√≥n del c√≥digo hasta que se complete la tarea, se puede utilizar una funci√≥n as√≠ncrona para que la tarea se ejecute en segundo plano y el resto del c√≥digo siga ejecut√°ndose mientras tanto.
ejemplo:
async function miFuncionAsincrona() {
  // Hacer una solicitud a un servidor
  const resultado = await fetch('https://mi-servidor.com/datos');
  // Hacer algo con los datos obtenidos de la solicitud
  console.log(resultado);
  // Devolver un valor
  return resultado;
}
**la funci√≥n miFuncionAsincrona utiliza la palabra clave async
**hace una solicitud a un servidor utilizando la funci√≥n fetch
**await se utiliza para esperar a que se resuelva la promesa y obtener el resultado de la solicitud.

ES6: generator.
Los generadores son funciones especiales que pueden pausar su ejecuci√≥n, luego volver al punto donde se quedaron, recordando su scope y seguir retornando valores.
Estos se utilizan para guardar la totalidad de datos infinitos, a trav√©s de una funci√≥n matem√°tica a valores futuros. De esta manera ocupan poca memoria, con respecto a si creamos un array u objeto.

C√≥mo utilizar generadores
La sintaxis de los generadores comprende lo siguiente:

La palabra reservada function* (con el asterisco al final).
La palabra reservada yield que hace referencia al valor retornado cada vez que se invoque, recordando el valor anterior.
Crear una variable a partir de la funci√≥n generadora.
El m√©todo next devuelve un objeto que contiene una propiedad value con cada valor de yield; y otra propiedad done con el valor true o false si el generador ha terminado.
Si el generador se lo invoca y ha retornado todos sus valores de yield, entonces devolver√° el objeto con las propiedades value con undefined y un done con true.

// Declaraci√≥n
function* nombre(par√°metros){
    yield (primer valor retornado)
    yield (segundo valor retornado)
    ...
    yield (√∫ltimo valor retornado)

}

//Crear el generador
const generador = nombre(argumentos)

// Invocacioens
generador.next().value //primer valor retornado
generador.next().value //segundo valor retornado
...
generador.next().value //√∫ltimo valor retornado

Ejemplo de un generador
Por ejemplo, creemos un generador para retornar tres valores.
function* generator(){
    yield 1
    yield 2
    yield 3
}

const generador = generator()

generador.next().value //1
generador.next().value //2
generador.next().value //3
generador.next() // {value: undefined, done: true}

documentacion generadores: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Generator

C√≥mo utilizar for of (para el valor) y for in (para el index o llave)
Existen dos nuevas formas de utilizar ciclos repetitivos. El bucle for valor of iterable recorre iterables, como arrays, Map, Set e incluso un generador.

El valor es cada elemento del iterable puede tener cualquier nombre, por eso se inicia con let nombre.

const array = [5, 4, 3, 2, 1]

for (let numero of array) {
  console.log(numero) // 5 4 3 2 1
}

Sin embargo, debes tener en cuenta que solo podr√°s acceder a sus valores, y no a sus referencias, por lo que si quieres cambiar los elementos del array, necesitar√°s un √≠ndice array[indice].

for (let numero of array) {
  valor *= 2 //esto es igual a valor=valor*2
  console.log(numero) // 10 8 6 4 2
}
 
console.log(array) // [ 5, 4, 3, 2, 1 ]

Si intentas recorrer un objeto de esta forma for elemento of objeto, te ocurrir√° un error, porque un objeto no es un iterable. En su lugar puedes utilizar for elemento in objeto, que recorrer√° las propiedades del objeto.
const objeto = { a: 1, b: 2, c: 3 }

for (let elemento in objeto) {
  console.log(elemento) // 'a' 'b' 'c'
}

Sin embargo, si utilizas for elemento in array, no dar√° un error, pero el resultado no ser√° el esperado, ya que los arrays son un tipo de objeto donde cada propiedad es el √≠ndice del valor del array o del iterable. Por lo que debes tener cuidado.
const array = [5, 4, 3, 2, 1]

for (let elemento in array) {
  console.log(elemento) // '0' '1' '2' '3' '4'
}

/* const array = {
	'0': 5,
  '1': 4,
  '2': 3,
  '3': 2,
  '4': 1
}*/











</code></pre>

</div>

</body>
</html>
